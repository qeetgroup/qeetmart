import { existsSync, readFileSync, readdirSync, statSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, "../../..");

const sourceOpenapiDir = path.join(repoRoot, "contracts", "openapi");
const docsOpenapiDir = path.join(repoRoot, "apps", "docs", "openapi", "v1");
const envCatalogPath = path.join(repoRoot, "apps", "docs", "src", "data", "env-vars.v1.json");
const readmeOutputDir = path.join(repoRoot, "apps", "docs", "content", "v1", "services", "readmes");

const serviceEnvFiles = {
  "api-gateway": "micros/api-gateway/.env.example",
  "auth-service": "micros/auth-service/.env.example",
  "user-service": "micros/user-service/.env.example",
  "product-service": "micros/product-service/.env.example",
  "inventory-service": "micros/inventory-service/.env.example",
};

const syncServices = ["api-gateway", "auth-service", "user-service", "product-service", "inventory-service"];

const parseEnvNames = (content) => {
  return content
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line && !line.startsWith("#") && line.includes("="))
    .map((line) => line.split("=")[0]?.trim())
    .filter(Boolean);
};

const titleFromService = (service) => {
  return service
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
};

const getExpectedReadmeDoc = (service) => {
  const readmePath = path.join(repoRoot, "micros", service, "README.md");
  let body = "";
  let lastUpdated = "N/A";

  if (existsSync(readmePath)) {
    body = readFileSync(readmePath, "utf8").trim();
    lastUpdated = statSync(readmePath).mtime.toISOString().slice(0, 10);
  } else {
    body = `No \`README.md\` was found for \`micros/${service}\` during docs sync.\n\nAdd a README and run \`pnpm --filter docs sync:readmes\`.`;
  }

  const title = `${titleFromService(service)} README (Synced)`;
  return `---\ntitle: ${title}\ndescription: Synced from micros/${service}/README.md.\nsection: Services\nlastUpdated: ${lastUpdated}\n---\n\n<Callout title=\"Generated content\" tone=\"info\">\n  This page is generated by \`pnpm --filter docs sync:readmes\`.\n</Callout>\n\n${body}\n`;
};

const errors = [];

for (const sourceFile of readdirSync(sourceOpenapiDir)) {
  if (!sourceFile.endsWith(".openapi.json")) {
    continue;
  }

  const mappedName = sourceFile.replace(/\.openapi\.json$/, ".json");
  const sourcePath = path.join(sourceOpenapiDir, sourceFile);
  const targetPath = path.join(docsOpenapiDir, mappedName);

  if (!existsSync(targetPath)) {
    errors.push(`Missing synced OpenAPI file: apps/docs/openapi/v1/${mappedName}`);
    continue;
  }

  const sourceJson = JSON.parse(readFileSync(sourcePath, "utf8"));
  const targetJson = JSON.parse(readFileSync(targetPath, "utf8"));
  if (JSON.stringify(sourceJson) !== JSON.stringify(targetJson)) {
    errors.push(`OpenAPI mismatch: ${mappedName}. Run pnpm --filter docs sync:openapi`);
  }
}

const envCatalog = JSON.parse(readFileSync(envCatalogPath, "utf8"));
for (const [serviceName, relativePath] of Object.entries(serviceEnvFiles)) {
  const absolutePath = path.join(repoRoot, relativePath);
  const sourceVars = parseEnvNames(readFileSync(absolutePath, "utf8"));
  const documentedVars = new Set((envCatalog[serviceName] ?? []).map((entry) => entry.name));

  for (const envVar of sourceVars) {
    if (!documentedVars.has(envVar)) {
      errors.push(`Undocumented env var ${serviceName}.${envVar} in apps/docs/src/data/env-vars.v1.json`);
    }
  }
}

for (const service of syncServices) {
  const expected = getExpectedReadmeDoc(service);
  const outputPath = path.join(readmeOutputDir, `${service}.mdx`);

  if (!existsSync(outputPath)) {
    errors.push(`Missing synced README doc: apps/docs/content/v1/services/readmes/${service}.mdx`);
    continue;
  }

  const actual = readFileSync(outputPath, "utf8");
  if (actual !== expected) {
    errors.push(`Synced README drift detected for ${service}. Run pnpm --filter docs sync:readmes`);
  }
}

const runAllServicesDoc = readFileSync(
  path.join(repoRoot, "apps", "docs", "content", "v1", "local-development", "run-all-services.mdx"),
  "utf8",
);

for (const service of ["gateway", "auth-service", "user-service", "product-service", "inventory-service"]) {
  if (!runAllServicesDoc.includes(service)) {
    errors.push(`run-all-services.mdx must reference ${service}`);
  }
}

if (errors.length > 0) {
  console.error("Docs drift check failed:");
  for (const error of errors) {
    console.error(`- ${error}`);
  }
  process.exit(1);
}

console.log("Docs drift check passed.");
