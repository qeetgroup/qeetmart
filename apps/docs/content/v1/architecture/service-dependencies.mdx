---
title: Service Dependencies
description: Dependency direction and runtime coupling across gateway and microservices.
section: Architecture
lastUpdated: 2026-02-20
---

## Dependency model

<MermaidDiagram
  title="Service dependency graph"
  chart={`
flowchart TB
  NextJsWeb --> ApiGateway
  ExpoMobile --> ApiGateway
  AdminUi --> ApiGateway
  ApiGateway --> AuthService
  ApiGateway --> UserService
  ApiGateway --> ProductService
  ApiGateway --> InventoryService
  UserService --> AuthService
  ProductService --> AuthService
`}
/>

<Callout title="How to read this graph" tone="info">
  Arrows indicate runtime dependency direction. Failures usually propagate along arrow direction.
</Callout>

## Coupling constraints

- Service-to-service calls are intentionally minimized.
- Token verification is shared via JWT issuer and secret agreement.
- Contract evolution is managed through `contracts/openapi/*` checks.

## Failure behavior

- If a downstream service is unavailable, gateway returns `502`.
- Health fanout endpoint exposes per-service status.
- Rate limiter protects downstream services during incident spikes.

## Practical debugging sequence

1. Start at the failing client flow and identify the gateway route.
2. Follow one edge at a time to the next dependency.
3. Verify health and logs for each dependency before jumping services.
